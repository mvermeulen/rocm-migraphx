--- onnxruntime.orig/include/onnxruntime/core/framework/float16.h	2022-12-12 16:21:35.283570941 -0600
+++ onnxruntime/include/onnxruntime/core/framework/float16.h	2022-12-12 16:32:32.404919258 -0600
@@ -41,7 +41,7 @@
 // BFloat16
 struct BFloat16 {
   uint16_t val{0};
-#if defined(USE_ROCM)
+#if defined(__HIP__)
   ORT_HOST_DEVICE BFloat16() = default;
 #else
   BFloat16() = default;
@@ -54,7 +54,7 @@
   inline ORT_HOST_DEVICE BFloat16(float v) {
 #if defined(CUDA_VERSION) && CUDA_VERSION >= 11000 && defined(__CUDA_ARCH__) && __CUDA_ARCH__ >= 800
     val = __bfloat16_as_ushort(__float2bfloat16(v));
-#elif defined(USE_ROCM)
+#elif defined(__HIP__)
     // We should be using memcpy in order to respect the strict aliasing rule but it fails in the HIP environment.
     if (v != v) {  // isnan
       val = UINT16_C(0x7FC0);
@@ -81,7 +81,7 @@
   inline ORT_HOST_DEVICE float ToFloat() const {
 #if defined(CUDA_VERSION) && CUDA_VERSION >= 11000
     return __bfloat162float(*reinterpret_cast<const __nv_bfloat16*>(&val));
-#elif defined(USE_ROCM)
+#elif defined(__HIP__)
     // We should be using memcpy in order to respect the strict aliasing rule but it fails in the HIP environment.
     float result = 0;
     uint32_t tmp = val;
